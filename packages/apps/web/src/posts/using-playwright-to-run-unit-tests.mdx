---
title: Using Playwright Test to run Unit Tests
published: true
publishedAtISO: '2022-05-17T18:00:00.000Z'
description: How to use Playwright Test as a test runner for unit tests (as an alternative to Jest/Mocha) and fill in missing pieces (e.g. code coverage).
shortenedURL: use-playwright-test-for-unit-tests
tags: ['#playwright', '#testing', '#code-coverage']
---

I have used Playwright for a couple of my projects so far, and I had such a good experience that it got my E2E test automation tool of choice.

Recently, I started using Playwright Test, the test runner of Playwright ([`@playwright/test`](https://www.npmjs.com/package/@playwright/test)) **for unit tests** also.  
By unit test I mean the test subject **is executed directly**; this differs from the "usual" way of using Playwright to open a browser, navigate to a web page, and test that web page.

In this blog post, I want to

- describe what I like about Playwright and why I think it is a good idea to use it for unit tests
- outline things missing from Playwright compared to other test frameworks (and how to fill some of those gaps)
- suggest some minor tweaks to make Playwright more suitable for unit tests

## Why to use Playwright Test for unit tests

I had used "traditional" test runners before, mainly Jest, but also Mocha a few years ago.  
I think there are some advantages of using Playwright for unit tests:

- **Same tool for E2E tests and unit tests:**
  One tool less in your setup means one tool less to learn, configure, update, etc.
- **Out-of-the-box support for TypeScript:**
  Playwright Test supports TypeScript _out-of-the-box_.  
  For all other test runners I am aware of you have to configure some transform (Babel, `ts-jest`, etc.), or run the test runner with `ts-node`, or compile the test cases before running them (see e.g. <FancyAnchor href="https://jestjs.io/docs/getting-started#using-typescript">"Using Typescript" of the Jest docs</FancyAnchor>).
- **Access to features unique to Playwright:**
  Playwright has some very useful features, e.g.:

  - {/* prettier-ignore */}<FancyAnchor href="https://playwright.dev/docs/test-fixtures">"fixtures"</FancyAnchor> allow to prepare resources per test case or worker.  
    This is in my opinion much better than the `beforeEach` / `afterEach` fiddling you have to do with other test runners.
  - {/* prettier-ignore */}<FancyAnchor href="https://playwright.dev/docs/test-advanced#projects">"projects"</FancyAnchor> allow to run "the same or different tests in multiple configurations".  
    For example a while ago I had to make sure that some client/server interaction based on <FancyAnchor href="https://socket.io">socket.io</FancyAnchor> works with both WebSockets and HTTP long-polling.
    Setting up two Playwright projects with different project parameters allowed me to run the same tests with two configurations, once using WebSockets and once using HTTP long-polling.

- **Development funded by a big company:**
  Playwright is a product of Microsoft and has been maintained very actively over the last couple of years.
- **No use of globals:** Playwright does not use any globals for its test runner.
  You import from `@playwright/test` just what you need in your test files.

  Compare that to existing test runners like Jest and Mocha (and Cypress, using Mocha under-the-hood).
  Those test runners set up their test functions as globals (`it`, `expect`, `describe`, `beforeEach` etc.).  
  In TypeScript projects, as soon as you install any two of these test libraries you end up with TypeScript compilation errors, since the types of those functions are usually not compatible with each other.
  There are a couple of workarounds to avoid those compilation errors, for example fiddling with `tsconfig.json` such that types of these libraries are excluded or just disable type checking of libraries altogether (`skipLibCheck: true`).  
  Cypress even has a guide dedicated to this problem (<FancyAnchor href="https://docs.cypress.io/guides/tooling/typescript-support">AUTOGENERATE</FancyAnchor>).

  Having the same Playwright Test import statements in every test file might be some boilerplate, but I think the reduced friction (by not having any globals) justifies that boilerplate.

## Things missing from Playwright (and how to fill the gaps)

Compared to Jest, there are some things missing from Playwright Test which are often needed when running unit tests.  
Fortunately, we can fill those gaps using libraries from the Node.js ecosystem:

- **Code coverage:**
  A simple setup using the command-line interface [`nyc`](https://github.com/istanbuljs/nyc) of Istanbul (a code coverage tool for JavaScript) and [`source-map-support`](https://www.npmjs.com/package/source-map-support) does the job.  
  See this commit of the example repository I made: <FancyAnchor href="https://github.com/pkerschbaum/blog-playwright-for-unit-tests_example/compare/base-setup...code-coverage">AUTOGENERATE</FancyAnchor>.
- **Fakes/Spies/Stubs/Mocks:**
  Use [`sinon`](https://www.npmjs.com/package/sinon) or [`jest-mock`](https://www.npmjs.com/package/jest-mock) (the mocking solution shipped with Jest).
- **Fake timers:**
  Use [`sinon`](https://www.npmjs.com/package/sinon), see this commit of the example repository I made: <FancyAnchor href="https://github.com/pkerschbaum/blog-playwright-for-unit-tests_example/compare/code-coverage...fake-timers">AUTOGENERATE</FancyAnchor>.
- **CommonJS/ES module mocking:**
  Jest provides a way to mock CommonJS modules via `jest.mock` (ESM is not supported at the time of writing: <FancyAnchor href="https://github.com/facebook/jest/issues/10025">AUTOGENERATE</FancyAnchor>); since Playwright Test is executed with Node.js, [`testdouble`](https://github.com/testdouble/testdouble.js) should work (but not tested).
- **Watch mode:** https://github.com/microsoft/playwright/issues/7035

## Other things to consider

- **Snapshot Suffix:**
  Playwright Test has a method `expect(...).toMatchSnapshot(...)` which can perform snapshot-comparisons on screenshots but also textual and binary data.  
  At the time of writing, Playwright will append a platform-specific suffix to the name of the file the snapshot is stored in.
  This makes sense for screenshots (since screenshots taken on differend platforms will deviate slightly, for example because of text rendering), but usually it does not make sense in case of textual/binary data.

  This is an open issue (<FancyAnchor href="https://github.com/microsoft/playwright/issues/11134">AUTOGENERATE</FancyAnchor>), for now we can disable the suffix by setting up an "auto-fixture" and override `testInfo.snapshotSuffix`:

  ```typescript
  import { test as base } from '@playwright/test';

  export const test = base.extend<{ _autoSnapshotSuffix: void }>({
    _autoSnapshotSuffix: [
      async ({}, use, testInfo) => {
        testInfo.snapshotSuffix = '';
        await use();
      },
      { auto: true },
    ],
  });
  ```
