---
title: TODO
published: true
publishedAtISO: '2023-01-01T00:00:00.000Z'
description: TODO
shortenedURL: TODO
tags: ['TODO']
---

I have been using monorepos for my TypeScript projects for about 2 years now.  
During this time I have stumbled upon many problems and challenges.  
If you have worked in monorepos already, this (incomplete) list of issues might sound familiar:

- Some compilation/build error goes away if I delete all `node_modules` and install them again.
- Adding a dependency in package A breaks the build of package B.
- Jump-to-declaration does not work across packages in the monorepo.
- Some package can be consumed by a package A, but a TypeScript error occurs when consuming the same package from another package B.
- Using path aliases in a package screws up all packages which depend on it.

I worked through many of such issues and landed on a monorepo setup which works really well for me.

The goal of this blog post series is to **present the concerns you have/might have to deal with when setting up a monorepo for TypeScript packages, and solutions for them**.  
This first blog post you are reading right now is called **Essentials üè†**.
You can use it to set up a TS monorepo from scratch and you will have a working monorepo.  
The second one is called **Improvements üöÄ** and will show how to improve the developer experience, how to get down build times, how to set up pre-commit hooks, ...

## Goal

The monorepo structure we aim for looks like this:

```txt
packages/
  apps/
    app-a/
    app-b/
    ...
  libs/
    lib-a/
    lib-b/
    ...
package.json
```

The monorepo consists of _apps_ and _libs_:

- An _application_ is something that is runnable.
  Be it a web frontend, Node.js HTTP server, or some CLI.  
  Apps may not depend on each other. They may depend on _libs_.
- A _library_ is non-runnable.
  It can be consumed by apps, other libs, or both.  
  There can be many reasons to create a library. One reason is to share code between multiple apps and libs.
  Another reason is to enforce modularization in an application, since a package is the hardest boundary you can create in a JS/TS project (a package has its own dependencies, and circular dependencies are not possible).

A note on the term _workspace_. Unfortunately, this term is kind of ambiguous in the JS ecosystem.  
Different tools of the monorepo tooling problem space will refer to different things when using this term.  
What I know is that <FancyAnchor href="https://pnpm.io/workspaces">`pnpm`</FancyAnchor> uses the term to refer _to the monorepo itself_ as one "workspace", and uses the term "packages" or "projects" to refer to the packages inside the monorepo.  
This seems to be the same definition <FancyAnchor href="https://nx.dev/getting-started/nx-setup">`nx`</FancyAnchor> is using.

That's why in this blog post series, I will use _workspace_ to refer to the monorepo, and _package_ to refer to the TypeScript packages inside of that monorepo (apps and libs).

## Some Guiding Principles

- **Autonomy of packages:**
  TSC/eslint/prettier can be configured per package;
  a package might not even use TypeScript;
  build/test/etc. can be configured by each package.
  ESM or CJS is decided by each package.
- **No surprises:**
  No phantom dependencies;
  deterministic behavior during builds
- **Scalability in number of packages:** Imagine you have an _app_ and it depends on a couple of _libs_. TODO build time lets say 30sec. one year later 100 packages more, but that app and libs untouched. how long should be build time? still 30sec.

## Package Management

> TL;DR use `pnpm` as package manager; avoid putting dependencies into root `node_modules` as much as possible.

- hoisting of `node_modules` introduces many problems:
  - phantom dependencies
  - `@types/*` packages alter compilation process of TS projects in the monorepo.
  - `eslint` might not find configs and plugins.
  - violates "package autonomy"
- npm workspaces and yarn classic workspaces are unusable because of their hoisting behavior of `node_modules`.
  Creates all the problems listed above.
  yarn classic allows to disable hoisting for specific packages or even altogether, but that has a huge impact on dependency installation duration and disk space.
- pnpm has worked out the deduplication of `node_modules`.
  Uses symlinks instead of hoisting to deduplicate dependencies.
  Does not suffer from the problems listed above.
- where to put dependencies? root `package.json` or in the package's `package.json`?
  - guiding principle: be very restrictive of what you put into the root `package.json`. Eligible deps are
    - deps related to Git Workflows (`husky`, `lint-staged`)
    - deps related to Monorepo tooling (`nx`, `turborepo`)
    - deps polyfilling binaries for platforms not supporting them, and where only one specific version is needed/wanted for the entire monorepo (e.g. `rimraf`, `mkdirp`)
    - and maybe prettier (to enforce exactly the same code formatting in the entire monorepo)
  - `pnpm up` can be used to update dependencies across the monorepo, easens the drawback that many different versions of packages (say, `typescript`) are present in the monorepo in multiple places.
- `.npmrc`:
  - `strict-peer-dependencies=true` (peer dependencies must be present and have the correct version)
  - `public-hoist-pattern[]=` (disable public-hoist-pattern entirely to avoid phantom dependencies)
  - `save-workspace-protocol=true` (use the `workspace:` prefix in `package.json` files to make it explicit that the dependency is a workspace dependency)

## Package Configuration

- use a separate `tsconfig.json` for every package.

  ```jsonc
  {
    "compilerOptions": {
      /* ... */
      "declaration": true,
      "declarationMap": true,
      "outDir": "./dist",
      "sourceMap": true
    }
  }
  ```

- create a `eslint-template.cjs` containing a standard configuration for the entire monorepo, and let `.eslintrc.cjs` of every package inherit from that
- make use of `exports` and `typesVersions` to define what is exported from the package
- each package can/should implement some NPM scripts: `nuke`, `build`, `lint`, `compile`, ... can do whatever it wants in each script
- all `eslint`-related deps are put in every `package.json`.
  Kind of noisy, but benefit is that problems with `eslint` execution are avoided, no surprises.
  Packages can also update their `eslint` deps independently.
- `typescript` also per package

## Development Process

- let packages implement `compile:watch` such that
  -- libraries run **type checking** and **emit output**
  -- runnables only run **type checking**
- `tsc --watch --preserveWatchOutput`
- then, run a development script for the runnable in question separately

## Task Orchestration and Build Process

- `pnpm --recursive run`; runs in parallel as much as possible while respecting dependency DAG.
  Supports to filter (e.g. `--filter @repo/web...` will run the command on `@repo/web` and its dependencies, in inverse order etc.)

## Appendix: How-To Path Aliases

- unfortunately, `tsc` does not support to replace path aliases in the emitted output
- install `ts-patch` and `typescript-transform-paths`. Add `"postinstall": "ts-patch install -s"`.  
  Add to `tsconfig.json`:

  ```json
  "plugins": [
    {
      "transform": "typescript-transform-paths"
    },
    {
      "transform": "typescript-transform-paths",
      "afterDeclarations": true
    }
  ]
  ```

## Appendix: Improve Cross-Package TS Intellisense using TS Project References

- rename all `tsconfig.json`'s to `tsconfig.project.json`
- create one `tsconfig.json` using project references to reference all of these projects.
  VS Code will pick up that tsconfig.

## Appendix: Add Build Caching via `nx`

## Appendix: Add fine-grained pre-commit compile/lint/format using husky and lint-staged

## Further Reading

- [https://monorepo.tools](https://monorepo.tools)

TODO maybe mention that there can be dirs other than "apps" and "libs"?
